#!/bin/bash
# PhoenixShield - Self-Healing Backup & Update System
# Version: 1.0.0

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
PHOENIX_DIR="${PHOENIX_DIR:-/var/backups/phoenix}"
PHOENIX_CONFIG="${PHOENIX_CONFIG:-./phoenix-shield.yaml}"
PHOENIX_LOG="${PHOENIX_LOG:-/var/log/phoenix-shield.log}"
RECOVERY_MODE=false

# Logging
log() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$PHOENIX_LOG"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$PHOENIX_LOG"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a "$PHOENIX_LOG"
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1" | tee -a "$PHOENIX_LOG"
}

# ==================== COMMANDS ====================

cmd_init() {
    local project="${1:-default}"
    local backup_dir="${2:-$PHOENIX_DIR}"
    
    log "ðŸ”¥ Initializing PhoenixShield for project: $project"
    
    mkdir -p "$backup_dir/$project"/{snapshots,logs,configs}
    
    # Create default config
    cat > "phoenix-shield.yaml" <<'EOF'
project: $project
backup:
  directory: $backup_dir
  retention: 10
  compression: gzip

health_checks:
  - command: "echo 'OK'"
    interval: 30s
    retries: 3

monitoring:
  enabled: true
  duration: 24h
  intervals:
    critical: 1m
    normal: 5m
    extended: 30m
    stability: 2h

rollback:
  strategy: smart
  auto_rollback: true
  max_attempts: 3

notifications:
  on_start: true
  on_success: true
  on_failure: true
  on_rollback: true
EOF

    log "âœ… PhoenixShield initialized"
    log "   Config: ./phoenix-shield.yaml"
    log "   Backups: $backup_dir/$project"
}

cmd_preflight() {
    log "ðŸ§ª Running pre-flight checks..."
    
    local failed=0
    
    # Check disk space (need at least 1GB)
    local available=$(df / | tail -1 | awk '{print $4}')
    if [ "$available" -lt 1048576 ]; then
        error "Insufficient disk space (need 1GB, have $(($available/1024))MB)"
        failed=1
    else
        log "âœ… Disk space OK ($(($available/1024))MB available)"
    fi
    
    # Check backup directory
    if [ ! -d "$PHOENIX_DIR" ]; then
        warn "Backup directory doesn't exist, creating..."
        mkdir -p "$PHOENIX_DIR"
    fi
    
    if [ ! -w "$PHOENIX_DIR" ]; then
        error "Cannot write to backup directory: $PHOENIX_DIR"
        failed=1
    else
        log "âœ… Backup directory writable"
    fi
    
    # Check for critical processes
    local critical_procs=$(ps aux | grep -E "npm install|webpack|vite build|docker build" | grep -v grep | wc -l)
    if [ "$critical_procs" -gt 0 ]; then
        warn "Detected $critical_procs build processes running"
        log "   Consider waiting for builds to complete"
    else
        log "âœ… No critical build processes detected"
    fi
    
    # Check network
    if ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        log "âœ… Network connectivity OK"
    else
        warn "Network connectivity issues detected"
    fi
    
    if [ $failed -eq 0 ]; then
        log "âœ… All pre-flight checks passed"
        return 0
    else
        error "âŒ Pre-flight checks failed"
        return 1
    fi
}

cmd_snapshot() {
    local name="${1:-snapshot-$(date +%Y%m%d-%H%M%S)}"
    local snapshot_dir="$PHOENIX_DIR/snapshots/$name"
    
    log "ðŸ“¸ Creating snapshot: $name"
    
    mkdir -p "$snapshot_dir"
    
    # Save system state
    {
        echo "SNAPSHOT_NAME=$name"
        echo "SNAPSHOT_DATE=$(date -Iseconds)"
        echo "PWD=$PWD"
        echo "USER=$USER"
        ps aux > processes.txt
        df -h > disk-usage.txt
        dpkg --get-selections > packages.txt 2>/dev/null || true
        npm list -g --depth=0 > npm-packages.txt 2>/dev/null || true
    } > "$snapshot_dir/meta.env"
    
    # Create backup if config files exist
    if [ -f "package.json" ]; then
        cp package.json "$snapshot_dir/"
    fi
    
    if [ -d ".openclaw" ]; then
        tar -czf "$snapshot_DIR/openclaw-config.tar.gz" .openclaw/ 2>/dev/null || true
    fi
    
    # Calculate checksums
    find "$snapshot_dir" -type f -exec md5sum {} \; > "$snapshot_dir/checksums.md5"
    
    log "âœ… Snapshot created: $snapshot_dir"
    echo "$snapshot_dir"
}

cmd_backup() {
    local type="${1:-full}"
    local backup_name="backup-$(date +%Y%m%d-%H%M%S)"
    local backup_dir="$PHOENIX_DIR/snapshots/$backup_name"
    
    log "ðŸ’¾ Creating $type backup: $backup_name"
    
    mkdir -p "$backup_dir"
    
    case "$type" in
        full)
            # Full system backup
            log "   Saving system state..."
            cmd_snapshot "$backup_name" >/dev/null
            
            # Backup important configs
            log "   Backing up configurations..."
            tar -czf "$backup_dir/configs.tar.gz" \
                /root/.openclaw/ \
                /etc/nginx/ 2>/dev/null || true
            ;;
            
        incremental)
            # Only changed files
            log "   Finding changed files..."
            # Implementation depends on tracking
            ;;
            
        config)
            # Config only
            log "   Backing up configurations only..."
            tar -czf "$backup_dir/configs.tar.gz" \
                /root/.openclaw/ 2>/dev/null || true
            ;;
    esac
    
    # Create restore script
    cat > "$backup_dir/restore.sh" <<'EOF'
#!/bin/bash
# PhoenixShield Restore Script
# Backup: $backup_name
# Created: $(date)

echo "Restoring from $backup_name..."
# Add restore logic here
echo "Restore complete!"
EOF
    chmod +x "$backup_dir/restore.sh"
    
    log "âœ… Backup complete: $backup_dir"
}

cmd_deploy() {
    local command="$1"
    local rollback_on_failure=false
    local health_checks=()
    
    # Parse arguments
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --rollback-on-failure)
                rollback_on_failure=true
                shift
                ;;
            --health-check)
                health_checks+=("$2")
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    log "ðŸš€ Starting safe deployment"
    log "   Command: $command"
    
    # Pre-flight
    if ! cmd_preflight; then
        error "Pre-flight checks failed, aborting deployment"
        return 1
    fi
    
    # Create snapshot before update
    local snapshot=$(cmd_snapshot "pre-deploy-$(date +%Y%m%d-%H%M%S)")
    log "   Snapshot created: $snapshot"
    
    # Capture baseline
    local baseline_health=$(check_health "${health_checks[@]}")
    log "   Baseline health: $baseline_health"
    
    # Execute update
    log "   Executing: $command"
    if eval "$command" 2>&1 | tee -a "$PHOENIX_LOG"; then
        log "âœ… Command executed successfully"
    else
        error "âŒ Command failed"
        if [ "$rollback_on_failure" = true ]; then
            log "   Initiating automatic rollback..."
            cmd_rollback "$snapshot"
        fi
        return 1
    fi
    
    # Post-update health checks
    log "   Running post-update health checks..."
    local attempts=0
    local max_attempts=5
    
    while [ $attempts -lt $max_attempts ]; do
        if check_health "${health_checks[@]}"; then
            log "âœ… Health checks passed"
            break
        else
            attempts=$((attempts + 1))
            warn "Health check failed (attempt $attempts/$max_attempts)"
            sleep 10
        fi
    done
    
    if [ $attempts -eq $max_attempts ]; then
        error "âŒ Health checks failed after $max_attempts attempts"
        if [ "$rollback_on_failure" = true ]; then
            log "   Initiating automatic rollback..."
            cmd_rollback "$snapshot"
        fi
        return 1
    fi
    
    # Start monitoring
    log "   Starting post-deployment monitoring..."
    cmd_monitor --duration 2h &
    
    log "âœ… Deployment complete"
    log "   Snapshot: $snapshot"
    log "   Monitor: Run 'phoenix-shield status' to check"
}

cmd_monitor() {
    local duration="${2:-24h}"
    local log_file="$PHOENIX_DIR/logs/monitor-$(date +%Y%m%d-%H%M%S).log"
    
    log "ðŸ“Š Starting monitoring for $duration"
    
    # Convert duration to seconds
    local seconds=$(echo "$duration" | sed 's/h/*3600/;s/m/*60/;s/s/*1/' | bc)
    
    local start_time=$(date +%s)
    local end_time=$((start_time + seconds))
    
    while [ $(date +%s) -lt $end_time ]; do
        local elapsed=$(($(date +%s) - start_time))
        local remaining=$((end_time - $(date +%s)))
        
        # Log status
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Elapsed: ${elapsed}s, Remaining: ${remaining}s" >> "$log_file"
        
        # Check critical services
        if ! systemctl is-active --quiet nginx 2>/dev/null; then
            warn "Nginx not running!" | tee -a "$log_file"
        fi
        
        # Sleep based on phase
        if [ $elapsed -lt 300 ]; then
            sleep 60      # First 5 min: every min
        elif [ $elapsed -lt 1800 ]; then
            sleep 300     # 5-30 min: every 5 min
        elif [ $elapsed -lt 7200 ]; then
            sleep 1800    # 30-120 min: every 30 min
        else
            sleep 7200    # After 2h: every 2h
        fi
    done
    
    log "âœ… Monitoring complete: $log_file"
}

cmd_rollback() {
    local snapshot="${1:-}"
    local dry_run=false
    
    if [ "$1" = "--dry-run" ]; then
        dry_run=true
        snapshot="${2:-}"
    fi
    
    if [ -z "$snapshot" ]; then
        # Find latest snapshot
        snapshot=$(ls -t "$PHOENIX_DIR/snapshots" 2>/dev/null | head -1)
        if [ -z "$snapshot" ]; then
            error "No snapshot found for rollback"
            return 1
        fi
    fi
    
    log "ðŸ”„ Rolling back to: $snapshot"
    
    if [ "$dry_run" = true ]; then
        log "   [DRY RUN] Would rollback to: $PHOENIX_DIR/snapshots/$snapshot"
        log "   [DRY RUN] Files to restore:"
        ls -la "$PHOENIX_DIR/snapshots/$snapshot/" 2>/dev/null || echo "   (no files)"
        return 0
    fi
    
    # Execute rollback
    local snapshot_dir="$PHOENIX_DIR/snapshots/$snapshot"
    
    if [ -f "$snapshot_dir/restore.sh" ]; then
        log "   Executing restore script..."
        bash "$snapshot_dir/restore.sh"
    else
        log "   Manual restore required from: $snapshot_dir"
    fi
    
    log "âœ… Rollback complete"
}

cmd_status() {
    log "ðŸ“‹ PhoenixShield Status"
    
    echo ""
    echo "Configuration:"
    echo "  Backup dir: $PHOENIX_DIR"
    echo "  Log file: $PHOENIX_LOG"
    
    echo ""
    echo "Snapshots:"
    if [ -d "$PHOENIX_DIR/snapshots" ]; then
        ls -lh "$PHOENIX_DIR/snapshots" | tail -n +2 | awk '{printf "  %s - %s\n", $9, $5}'
    else
        echo "  No snapshots found"
    fi
    
    echo ""
    echo "Latest log entries:"
    if [ -f "$PHOENIX_LOG" ]; then
        tail -5 "$PHOENIX_LOG"
    else
        echo "  No logs yet"
    fi
}

cmd_help() {
    cat <<'EOF'
PhoenixShield ðŸ”¥ðŸ›¡ï¸ - Self-Healing Backup & Update System

Usage: phoenix-shield <command> [options]

Commands:
  init [project] [backup-dir]     Initialize PhoenixShield
  preflight                       Run pre-update checks
  snapshot [name]                 Create system snapshot
  backup [full|incremental|config] Create backup
  deploy --command "cmd"          Execute safe update
    --rollback-on-failure         Auto-rollback on failure
    --health-check "cmd"          Add health check
  monitor --duration [time]       Monitor post-update
  rollback [snapshot]             Rollback to snapshot
    --dry-run                     Preview rollback
  status                          Show status
  help                            Show this help

Examples:
  phoenix-shield init myapp /var/backups
  phoenix-shield preflight
  phoenix-shield snapshot pre-update
  phoenix-shield deploy --command "npm update" --rollback-on-failure

EOF
}

# Helper functions
check_health() {
    local checks=("$@")
    local failed=0
    
    for check in "${checks[@]}"; do
        if ! eval "$check" >/dev/null 2>&1; then
            failed=$((failed + 1))
        fi
    done
    
    if [ $failed -eq 0 ]; then
        echo "healthy"
        return 0
    else
        echo "unhealthy ($failed failed)"
        return 1
    fi
}

# ==================== MAIN ====================

main() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        preflight|check)
            cmd_preflight "$@"
            ;;
        snapshot)
            cmd_snapshot "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        deploy|update)
            cmd_deploy "$@"
            ;;
        monitor)
            cmd_monitor "$@"
            ;;
        rollback|restore)
            cmd_rollback "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
